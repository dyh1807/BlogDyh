---
title: Compiler-CodeGen
date: 2023-06-06 20:46:41
tags:
- Compiler
categories:
- Compiler
- Learning Notes
---

> 记录下 DragonBook 第八章的学习

## Task for Code Generator
代码生成器的工作：接收 IR，高效产生目标代码。

## 8.1 代码生成器设计中的问题

### 寄存器的使用
分为2个子问题：
1. 寄存器分配：选择出一组将被放在寄存器中的变量
2. 寄存器指派：指定变量将被放在哪个寄存器中

## 8.2 目标语言

### 程序和指令的代价

不同的指令具有不同的代价。

简单的划分：一条指令的代价为： $1 + 访存代价$

## 8.3 目标代码中的地址

> 静态和栈式的内存分配是调用和返回生成代码的两种方式

### 静态分配
静态分配是一种函数调用的方法，指的是把被调用函数`callee`的返回地址存储到其静态区域`callee.staticArea`的方法。

### 栈分配
使用栈记录函数的活动记录。需要寄存器SP指向栈顶。

### 名字的运行时地址
三地址码相对地址+对应的分配策略（静态static 或者 栈式分配）对应的偏移=名字的运行时地址。

## 8.4 基本块和流图

基本块：最大连续三地址指令序列。在基本块最后一条指令前，不会发生跳转、停机。

流图(flow graph)：基本块之间存在先后运行关系，构成流图。

### 后续有用信息

名字`x`在语句（指令）`i`处活跃：存在后续的指令`j`使用了在指令`i`处被赋值的名字`x`

### 循环

称流图中的结点集合`L`是一个循环，如果：  
1. L存在一个循环入口结点（L中，只有入口结点可以存在非L中结点前驱）
2. 每个结点都有一条在L中的路径可以达到入口结点。

## 8.5 基本块的优化

### 基本块的 DAG 表示

> Here it refers to the DAG representation within a basic block

构造DAG有以下的基本原则：
1. for each variable, there is a DAG node w.r.t it's initialize value(in this basic block)
2. ..
3. ..
4. 有的结点称为output node，它们在基本块的出口处活跃。

By DAG, we can do:
1. eliminate local common subexpression
2. eliminate dead code
3. reorder instructions
4. simplify calculation

## 8.7 窥孔优化

一种局部优化技术，每一轮检查时维护一个滑动窗口中的指令，并用更优化的指令替代。可能需要经历多轮优化才能达到最优的优化效果。

### 消除冗余 load/store
同一个基本块中：如果有类似

```
LD R0, a
ST a, R0
```

则可以删除ST指令。

### 消除不可达代码

删除不可达代码

### 控制流优化

删除不必要的跳转指令:

```
goto L1
...
L1: goto L2
```

替换为

```
goto L2
...
L1: goto L2
```

### 其它

代数化简、强度消减、使用机器特有指令等。

## （附加）程序分析技术

分类：

1. 流分析
2. 依赖分析
3. 指针分析和别名分析
   
### 流分析

使用静态程序分析，给出动态时刻程序中变量的使用情况。

### 控制流图

即流图。可以通过DFS遍历控制流图，获得一棵 dfs spanning  tree。

### 数据流分析

程序状态：程序中的所有变量的值组成程序的状态。

程序点（非标准定义）：可以理解成执行到某个位置时的程序状态。（position+status）

执行路径：一个点列 p1, p2, ..., pn

#### 数据流分析模式

每个程序点和一个值（数据流值）关联。数据流值是该点可能观察到的所有程序状态的集合的抽象表示。

每条语句之前和之后的数据流值记为 IN[s] 和 OUT[s]。

传递函数：语句前后的数据流关系映射 $f_s$. 

$$
OUT[s] = f_s(IN[s])
$$

控制流具有约束：

$$
IN[s_{i+1}] = OUT[s_{i}]
$$

同样的描述方法可以推广到基本块上，记 IN[B] 、 OUT[B].

## 到达-定值(reach definition)

变量x的定值：可以赋值给x的语句。

gen[B]: 基本块B的定值d可到达B的结束点，则$d\in gen[B]$
kill[B]: 不能到达B的结束点的定值d的集合。


### 引用-定值链（ud链）

是到达—定值信息的一种存储方式

记录到达变量的某个引用的所有可能的定值集合


### 定值-引用链（du链）

给出变量的某个定值可以到达的引用点的集合。

### 可用表达式

表达式$x+y$在点 p 可用：初始结点到 p 的每条路径上都计算$x+y$，并且在最后这样的计算和p之间没有对x或y的赋值。（计算过表达式$x+y$并且保证此表达式的值不发生改变）

基本块注销表达式x+y：如果它对x或y赋值（或可能赋值），并且随后没有重新计算x+y

基本块产生表达式x+y：如果它计算x+y，并且随后没有重新对x或y定义

### 寄存器分配和指派

寄存器分配：决定哪些变量该占用寄存器  

寄存器指派：决定变量该使用哪个寄存器  

实际的寄存器分配策略：保留少量的寄存器做特殊用途，其它的寄存器由代码生成器决定使用。

使用计数法：把变量x保存在寄存器中的收益计算方法。大意是：每次对变量x的引用都节约了一个单位的开销。

图着色方法：扫描代码进行图着色。

#### 图着色方法

活跃区间：变量的定值和引用的子集。对应于变量定值点(definition)和引用点(Use)的一个连通区域。

干涉：两个变量的活跃区间干涉（简称两个变量干涉），若在其中某个变量的定值处，另一个变量是定值到达和活跃的。

图的k着色问题：用k色给图的顶点着色，使得相邻顶点之间没有相同的颜色。(NP hard)

寄存器分配归结为图的k着色问题：假设有k个 register 可用，将活跃区间抽象为 vertex，干涉的区间相当于存在 edge。

图着色问题的启发式方法：持续地从图中删掉度小于k的节点，若此过程一直进行到所有的节点均被删除，则图是k–可着色的。  
若此过程阻塞，即图中所有节点的度均不小于k，则依据溢出代价大小，从图中选择某个节点，删除该节点及其相连的边。然后重复上述过程。